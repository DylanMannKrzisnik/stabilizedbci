% plotSessionPerformance Create plot summarizing performance for a
% experimental session.
%
% This function plots session performance for the various blocks in the
% experimental session in the same style as Fig. 4b of the paper. Success
% rate and acquisition time are plotted for ~16-trial sets within each
% block if appropriate.
%
% Usage:
%   [F] = plotSessionPerformance(D)
%
% Inputs:
%   D   Structure array generated by the processTrialData function
%
% Outputs:
%   F   Handle to figure
%
% @ Alan Degenhart -- alan.degenhart@gmail.com

function [F] = plotSessionPerformance(D, titleStr)

% =========================================================================
% Process data

% Limit length of washout block
blockInds = 1:8; % Corresponding to 128 trials assuming a block size of 16
if strcmp(D(end).blockNotes,'Baseline Washout')
    D(end).blockSuccessRate = D(end).blockSuccessRate(blockInds);
    D(end).blockAcquireTimeSuccessMean = D(end).blockAcquireTimeSuccessMean(blockInds);
end

% Get success code and acquire time data
successCodeBlock = [D.blockSuccessRate] * 100;
acquireTimeBlock = [D.blockAcquireTimeSuccessMean]/1000;

% Get decoder changes -- these are used to indicate when the stabilizer was
% updated.
decMask = strcmp({D.blockNotes}, 'Stitching');
decTrans = cumsum([D.nBlocks]) + 0.5;
decTransStitching = decTrans(decMask);  % Get transitions for stabilizer
decTrans = [0.5, decTrans(1:(end-1))];

nStitchingUpdates = sum(decMask);
nBlocks = length(successCodeBlock);
blockSize = D(1).blockSize;

% Get highlight block data.  This allows the average data for the entirety
% of the evaluation blocks to be plotted.
evaluationBlockMask = [D.evaluationBlock];
Deval = D(evaluationBlockMask);
evalBlockNames = {Deval.blockNotes};
nEvalBlocks = length(Deval);
aT_eval = nan(nEvalBlocks,1);
sR_eval = nan(nEvalBlocks,1);
aT_eval_ci = nan(nEvalBlocks,2);
sR_eval_ci = nan(nEvalBlocks,2);

% Loop over evaluation blocks and calculate success rate, acquisition time,
% target acquisition rate
for i = 1:length(Deval)
    sC = Deval(i).successCode;
    aT = Deval(i).acquireTime/1000;
    
    % Limit to 128 trials for the washout block
    if strcmp(evalBlockNames{i},'Baseline Washout')
        sC = sC(1:128);
        aT = aT(1:128);
    end
    
    % Calcualte mean success rate, acquisition time, and target acquisition
    % rate
    aT_eval(i) = mean(aT(logical(sC)));
    sR_eval(i) = sum(sC)/length(sC) * 100;
    
    % Estimate confidence intervals
    aT_eval_ci(i,:) = confidenceInterval(aT);
    sR_eval_ci(i,:) = confidenceInterval(sC) * 100;
end

% =========================================================================
% Setup figure
nCol = 1;
nRow = 2;
axW = 750;
axH = 150;
axSp = 20;
xMargin = [75, 125];
[fW,fH,Ax] = calcFigureSize(nRow, nCol, axW, axH, axSp, ...
    'xMargin', xMargin);
F = figure('Position',[100 100 fW fH]);
set(F, 'color', 'w')

% Plot figure title
plotTitle(titleStr)

% =========================================================================
% Plot success rate

ax = subplotSimple(nRow, nCol, 1, 'Ax', Ax); hold on;

% Plot patches corresponding to evaluation blocks
yLim = [0 100];
plotEvaluationBlocks(D, decTrans, yLim)
plot(successCodeBlock, 'k.-', 'MarkerSize', 17, 'LineWidth', 1.5)
plot(repmat(decTransStitching,2,1), repmat(yLim', 1, nStitchingUpdates), ...
    'k--')
set(ax, ...
    'XLim', [0, nBlocks+1], ...
    'Box', 'off', ...
    'XTickLabel', [], ...
    'TickDir', 'out')
ylabel('% Success', 'FontSize', 14)
barAxis('y', [0, 100], [0, 100])
ax.XAxis.Visible = 'off';
ax.YAxis.Label.Visible = 'on';

% Plot average success rate for blocks
plotAverageSuccess(sR_eval, sR_eval_ci, evalBlockNames, Ax, 1, yLim)
set(gca, 'XTickLabel', [])  % Turn off tick labels

% =========================================================================
% Plot aquisition time

% Set those acquisition times where success rate is less than a pre-defined
% threshold to NaN.  The assumption here is that these acquisition times
% are invalid, as they don't adequately sample all targets.
srThresh = 50;
srMask = successCodeBlock <= srThresh;
acquireTimeBlock(srMask) = NaN;
maxAcquireTime = max(acquireTimeBlock);
maxAcquireTime = ceil(maxAcquireTime/0.5)*0.5;
acqTimeLim = [0 maxAcquireTime];
acqTimeNCLim = [1 2] + maxAcquireTime;
yNC = maxAcquireTime + 1.5;
acquireTimeBlock(srMask) = yNC;
evalMask = sR_eval < srThresh;
aT_eval(evalMask) = yNC;
aT_eval_ci(evalMask, :) = NaN;

ax = subplotSimple(nRow, nCol,2, 'Ax', Ax); hold on;
yLim = [0 ceil(max(acquireTimeBlock))];
plotEvaluationBlocks(D, decTrans, yLim)

% Plot acquisition times
acquireTimeX = find(srMask);
acquireTimeNC = acquireTimeBlock(srMask);
acquireTimeBlock(srMask) = NaN;
plot(acquireTimeBlock, 'k.-', 'MarkerSize', 17, 'LineWidth', 1.5)
plot(acquireTimeX, acquireTimeNC, 'r.', 'MarkerSize', 17); hold on;

% Plot lines indicating decoder transitions
plot(repmat(decTransStitching,2,1), repmat(yLim', 1, nStitchingUpdates), ...
    'k--')
set(ax, ...
    'XLim', [0 nBlocks+1], ...
    'YLim', yLim, ...
    'box', 'off', ...
    'XTickLabel', [], ...
    'TickDir', 'out')
xlabel(sprintf('Block (%d trials)', blockSize), 'FontSize', 14)
ylabel('Mean Acquisition Time (s)', 'FontSize', 14)

% Set y-tick label for 'non-computed' (NC) blocks
axLabels = cell(2, 2);
axLabels(1, :) = {'0', '4'};
axLabels(2,:) = {'NC', 'NC'};

% Set axis labels
barAxis('y', [acqTimeLim; acqTimeNCLim], [acqTimeLim; acqTimeNCLim], ...
    'axisTickLabels', axLabels)
set(ax,'YTick',[acqTimeLim acqTimeNCLim])
yTickLabel = {num2str(acqTimeLim(1)), num2str(acqTimeLim(2)),'NC','NC'};
set(ax,'YTickLabel', yTickLabel)
ax.XAxis.Visible = 'off';
ax.YAxis.Label.Visible = 'on';
ax.XAxis.Label.Visible = 'on';

% Plot average acquisition time for evaluation blocks
plotAverageSuccess(aT_eval, aT_eval_ci, evalBlockNames, Ax, 0, yLim)

end % EOF


function plotEvaluationBlocks(D, decTrans, yLim)
% Plot background for evaluation blocks.

% Get all evaluation blocks to plot
evalInds = find([D.highlightBlock]);

nEvalBlocks = length(evalInds);
for i = 1:nEvalBlocks
    xOnset = decTrans(evalInds(i));
    xOffset = xOnset + D(evalInds(i)).nBlocks;
    w = xOffset - xOnset;
    h = yLim(2) - yLim(1);
    
    rectangle('Position', [xOnset yLim(1) w h],...
        'FaceColor', getEvalBlockColor(D(evalInds(i)).blockNotes), ...
        'EdgeColor', 'None')
end

% Plot stabilizer blocks. Plotting these is slightly different b/c there
% are multiple stabilizer updates.
blockName = 'Stitching';
blockInds = find(strcmp({D.blockNotes}, blockName));
xOnset = decTrans(blockInds(1));
xOffset = decTrans(blockInds(end) + 1);
w = xOffset - xOnset;
h = yLim(2) - yLim(1);

rectangle('Position', [xOnset yLim(1) w h],...
    'FaceColor', getEvalBlockColor(blockName), ...
    'EdgeColor', 'None')
end % EOF


function plotAverageSuccess(data, data_ci, blockNames, Ax, plotNo, yLim)

% Plot average success rate for blocks
ax = subplot('Position', ...
    [Ax.xMarg(1) + Ax.axW/Ax.fW + Ax.xSp*0.75, ...
    Ax.yMarg(1) + plotNo*(Ax.axH/Ax.fH + Ax.ySp), ...
    Ax.xSp*2, ...
    Ax.axH/Ax.fH]);
hold on

% Iterate over evaluation blocks
nBlocks = length(blockNames);
for i = 1:nBlocks
    [~, colTemp] = getEvalBlockColor(blockNames{i});
    plot(i, data(i), 'color', colTemp, 'Marker', '.', 'MarkerSize', 17);
    hold on;
    errorbar(i, data(i), data(i) - data_ci(i,1), ...
        data_ci(i,2) - data(i), 'color', colTemp, 'LineWidth', 2)
end
set(ax, 'YLim', yLim, 'YTickLabel', [], 'TickDir', 'out', 'Color', 'None')
set(ax, 'XTickLabel', getBlockNameAbbrev(blockNames), ...
    'TickLength', 0.035 * ones(1, 2))
ax.YAxis.Visible = 'off';

end


function blockAbbrev = getBlockNameAbbrev(blockNames)
% Get abbreviations for block names

nBlocks = length(blockNames);
blockAbbrev = cell(1, nBlocks);

% Iterate over blocks and get abbreviation for each
for i = 1:length(blockNames)
    switch blockNames{i}
        case 'Baseline Evaluation'
            blockAbbrev{i} = 'B';
        case 'Stitching Evaluation'
            blockAbbrev{i} = 'S';
        case 'Perturbation Evaluation'
            blockAbbrev{i} = 'I';
        case 'Baseline Washout'
            blockAbbrev{i} = 'B';
    end  
end

end